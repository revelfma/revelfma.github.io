<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cursor use</title>
      <link href="/2025/02/21/cursor-use/"/>
      <url>/2025/02/21/cursor-use/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cursor软件使用</title>
      <link href="/2025/02/20/cursor-ruan-jian-shi-yong/"/>
      <url>/2025/02/20/cursor-ruan-jian-shi-yong/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>juyter</title>
      <link href="/2024/12/23/juyter/"/>
      <url>/2024/12/23/juyter/</url>
      
        <content type="html"><![CDATA[<h1 id="Jupyter-notebook"><a href="#Jupyter-notebook" class="headerlink" title="Jupyter notebook"></a>Jupyter notebook</h1><h2 id="1-Jupyter-notebook介绍"><a href="#1-Jupyter-notebook介绍" class="headerlink" title="1. Jupyter notebook介绍"></a>1. Jupyter notebook介绍</h2><p>Jupyter Notebook 是一个基于 Web 的交互式计算环境，支持多种编程语言，包括 Python、R、Julia 等。它的主要功能是将代码、文本、数学方程式、可视化和其他相关元素组合在一起，创建一个动态文档，用于数据分析、机器学习、科学计算和数据可视化等方面。Jupyter Notebook 提供了一个交互式的界面，使用户能够以增量和可视化的方式构建和执行代码，同时支持 Markdown 格式的文本和 LaTeX 数学符号。</p><p>但是要使用jupyter notebook， 我们首先得了解jupyter中内核的概念。</p><h2 id="2-内核的概念"><a href="#2-内核的概念" class="headerlink" title="2. 内核的概念"></a>2. 内核的概念</h2><h3 id="2-1-内核的比喻"><a href="#2-1-内核的比喻" class="headerlink" title="2.1 内核的比喻"></a>2.1 内核的比喻</h3><p>想象一下，你有一个魔法笔记本（Jupyter Notebook），你可以在这个笔记本上写下各种咒语（代码）。但是，这个笔记本自己并不能理解这些咒语，它需要一个魔法师（内核）来解读并执行这些咒语。</p><ol><li><p><strong>选择魔法师（内核）</strong>：当你打开魔法笔记本时，你需要选择一个魔法师，这个魔法师懂得特定的魔法语言（编程语言）。比如，你可以选择一个懂得 Python 魔法的魔法师，或者一个懂得 R 魔法的魔法师。</p></li><li><p><strong>写下咒语（代码）</strong>：你在这个笔记本上写下咒语（编写代码）。这些咒语是按照你选择的魔法师所懂得的语言写的。</p></li><li><p><strong>执行咒语（运行代码）</strong>：当你告诉魔法师执行咒语时，他会在你写下的咒语上施展魔法（运行代码），并把结果告诉你。</p></li><li><p><strong>显示结果</strong>：魔法师执行完咒语后，会将结果展示在你的笔记本上，这样你就可以看到咒语的效果了。</p></li></ol><h3 id="2-2-内核的详细解释"><a href="#2-2-内核的详细解释" class="headerlink" title="2.2 内核的详细解释"></a>2.2 内核的详细解释</h3><p>在 Jupyter Notebook 中，内核的工作方式与上面的比喻类似：</p><ol><li><p><strong>内核的选择</strong>：当你创建一个新的 Jupyter Notebook 时，你需要选择一个内核。这个内核决定了你可以在 Notebook 中使用哪种编程语言。比如，如果你选择 Python 内核，你就可以在 Notebook 中写 Python 代码。</p></li><li><p><strong>代码的执行</strong>：你在 Notebook 中写下的代码（即“单元格”中的代码）需要由内核来执行。当你运行一个代码单元格时，这个代码会被发送到内核。</p></li><li><p><strong>内核的处理</strong>：内核接收到代码后，会在其环境中执行这些代码。内核负责解释和执行代码，就像魔法师解读和执行咒语一样。</p></li><li><p><strong>返回输出</strong>：执行完毕后，内核会将输出（比如打印的结果、错误信息、生成的图表等）返回给 Jupyter Notebook，并显示在代码单元格下面。</p></li><li><p><strong>多语言支持</strong>：Jupyter Notebook 支持多种内核，这意味着你可以使用不同的编程语言。如果你想切换到另一种语言，你只需要更改 Notebook 的内核即可。</p></li><li><p><strong>内核的独立性</strong>：每个内核都是独立的，它们各自有自己的环境和状态。这意味着在一个内核中定义的变量或函数不会影响另一个内核。</p></li></ol><p>通过这种方式，Jupyter Notebook 允许我们在一个统一的界面中使用多种编程语言，进行数据分析、科学计算、可视化等多种任务。</p><h2 id="3-如何安装jupyter-notebook"><a href="#3-如何安装jupyter-notebook" class="headerlink" title="3. 如何安装jupyter notebook"></a>3. 如何安装jupyter notebook</h2><h3 id="方式一、利用anaconda安装"><a href="#方式一、利用anaconda安装" class="headerlink" title="方式一、利用anaconda安装"></a>方式一、利用anaconda安装</h3><h3 id="方式二、利用pip命令安装Jupyter-Notebook"><a href="#方式二、利用pip命令安装Jupyter-Notebook" class="headerlink" title="方式二、利用pip命令安装Jupyter Notebook"></a>方式二、利用pip命令安装Jupyter Notebook</h3><h2 id="1-安装-Python"><a href="#1-安装-Python" class="headerlink" title="1. 安装 Python"></a>1. 安装 Python</h2><p>首先，需要确保你的计算机上安装了 Python。</p><ul><li>访问 <a href="https://www.python.org/">Python 官网</a> 下载并安装 Python。</li><li>安装过程中，请确保将 Python 添加到你的系统路径（Path）中，这样可以在命令行中直接调用 <code>python</code> 命令。</li></ul><h2 id="2-使用-pip-安装-Jupyter-Notebook"><a href="#2-使用-pip-安装-Jupyter-Notebook" class="headerlink" title="2. 使用 pip 安装 Jupyter Notebook"></a>2. 使用 pip 安装 Jupyter Notebook</h2><p>Python 有一个包管理工具叫做 pip，它可以用来安装和管理 Python 包。</p><ul><li><p>打开命令行工具（在 Windows 上是 CMD 或 PowerShell，在 macOS 或 Linux 上是 Terminal）。</p></li><li><p>输入以下命令来安装 Jupyter Notebook：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install notebook</span><br></pre></td></tr></table></figure><p>或者，如果你使用的是 Python 3（推荐），你可能需要使用 <code>pip3</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install notebook</span><br></pre></td></tr></table></figure></li><li><p>启动 Jupyter Notebook</p></li></ul><p>安装完成后，你可以通过以下命令来启动 Jupyter Notebook：</p><ul><li><p>在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>这将在你的默认网页浏览器中打开 Jupyter Notebook 的界面。</p></li></ul><h2 id="4-访问-Jupyter-Notebook"><a href="#4-访问-Jupyter-Notebook" class="headerlink" title="4. 访问 Jupyter Notebook"></a>4. 访问 Jupyter Notebook</h2><ul><li><p>启动后，Jupyter Notebook 通常会在浏览器中自动打开。如果没有自动打开，命令行会显示一个 URL，你可以复制并粘贴到浏览器的地址栏中访问。</p></li><li><p>你将看到一个文件浏览器界面，在这里你可以创建新的 Notebook 或者打开已有的 Notebook。</p></li></ul><h2 id="5-创建一个新的-Notebook"><a href="#5-创建一个新的-Notebook" class="headerlink" title="5. 创建一个新的 Notebook"></a>5. 创建一个新的 Notebook</h2><ul><li>点击右上角的 “New” 按钮，然后选择一个内核（例如 Python 3），这将创建一个新的 Notebook。</li></ul><h2 id="6-开始使用-Jupyter-Notebook"><a href="#6-开始使用-Jupyter-Notebook" class="headerlink" title="6. 开始使用 Jupyter Notebook"></a>6. 开始使用 Jupyter Notebook</h2><ul><li>现在你可以开始在 Notebook 中编写和运行代码了。</li></ul><h2 id="7-保存和关闭-Notebook"><a href="#7-保存和关闭-Notebook" class="headerlink" title="7. 保存和关闭 Notebook"></a>7. 保存和关闭 Notebook</h2><ul><li><p>使用完 Notebook 后，记得保存你的工作。可以通过点击工具栏上的 “Save” 按钮来保存。</p></li><li><p>当你完成工作后，点击 “File” -&gt; “Close and Halt” 来关闭并停止 Notebook 服务器。</p></li></ul><p>通过以上步骤，你就可以在你的计算机上安装并使用 Jupyter Notebook 了。</p>]]></content>
      
      
      <categories>
          
          <category> Python 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神经工程学习笔记</title>
      <link href="/2024/12/12/shen-jing-gong-cheng-xue-xi-bi-ji/"/>
      <url>/2024/12/12/shen-jing-gong-cheng-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="植入式神经接口概述"><a href="#植入式神经接口概述" class="headerlink" title="植入式神经接口概述"></a>植入式神经接口概述</h1><h2 id="什么是植入式神经接口？"><a href="#什么是植入式神经接口？" class="headerlink" title="什么是植入式神经接口？"></a>什么是植入式神经接口？</h2><ul><li>直接与神经系统（中枢或外周）相连的设备</li><li>实现神经与外界的双向交互<ul><li>包括脑机接口（BCI）</li><li>神经假体（neuroprosthetics）</li><li>功能性电刺激（FES）</li></ul></li></ul><h2 id="植入式神经接口的特点与意义"><a href="#植入式神经接口的特点与意义" class="headerlink" title="植入式神经接口的特点与意义"></a>植入式神经接口的特点与意义</h2><ul><li>特点<ul><li>微创</li><li>高时空分辨率</li><li>复杂精细的功能修复</li></ul></li><li>意义<ul><li>修复受损神经通路</li><li>控制神经障碍疾病</li><li>重建运动和感觉通路</li></ul></li></ul><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><ul><li>2001年：侵入式脑机接口（i-BCI）</li><li>2005年：结合触觉的灵巧神经假肢（HAPTIX）</li><li>2013年：基于系统的神经技术新兴疗法（SUBNETS）</li><li>2018年：下一代微侵入性神经接口（N3）</li></ul><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul><li>残疾病人通过植入式神经接口控制机械手臂喂自己吃巧克力</li></ul><h2 id="系统构成"><a href="#系统构成" class="headerlink" title="系统构成"></a>系统构成</h2><ul><li>信号处理单元</li><li>植入式神经电极</li><li>通信单元</li><li>供电单元</li><li>中枢&#x2F;外周神经与外部设备</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>读取式Neural recording systems</li><li>写入式Neural stimulation systems</li></ul><p><img src="/2024/12/12/shen-jing-gong-cheng-xue-xi-bi-ji/%E6%A4%8D%E5%85%A5%E5%BC%8F%E8%84%91%E6%9C%BA%E6%8E%A5%E5%8F%A3%E8%84%91%E5%9B%BE.jpeg"><br><img src="/2024/12/12/shen-jing-gong-cheng-xue-xi-bi-ji/%E6%9C%BA%E5%99%A8%E4%BA%BA.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> BCI学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2阶幂零李群上的Laguerre演算（框架）</title>
      <link href="/2024/12/04/2-jie-mi-ling-li-qun-shang-de-laguerre-yan-suan-kuang-jia/"/>
      <url>/2024/12/04/2-jie-mi-ling-li-qun-shang-de-laguerre-yan-suan-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><blockquote><ul><li>随便抓取一个光滑流形的切丛的子丛，<strong>硬称</strong>其为horizontal向量丛（若维度与位置无关，称为这样的子切丛为regular distribution）$\mathscr{D}$，</li><li>bracket generating condition，并非是horizontal向量丛一定满足的性质。</li><li>以及二者的关系——Chou定理。</li></ul></blockquote><ul><li>次黎曼几何结构——$(M_n,\mathscr{D},&lt;\cdot,\cdot&gt;)$，其中$&lt;,&gt;$是D上的内积；</li><li>horizontal曲线的长度，由此定义出CC（与绝热过程有关）距离。</li></ul><blockquote><ul><li>结果1：cc距离与欧氏距离的关系——一个欧式球总可以找到一个cc球包含住。</li><li>结果2：算子（向量场）$\mathscr{L}&#x3D;\sum_{j&#x3D;1}^m X_j^2$ 满足<strong>次椭圆估计</strong>，即$\Vert|\nabla|^{\frac{2}{Q}}u\Vert_{L^2}\leq \hat{c}<em>Q{\Vert\mathscr{L}u\Vert</em>{L^2}+\tilde{c}<em>Q\Vert u\Vert</em>{L^2} }$，其中Q是幂零的阶数。相比椭圆算子估计，左边矮了一阶，可以参见之前写的文章。</li></ul></blockquote><p>例子:具有差速器的汽车后轮的运动描述。</p><h2 id="2阶幂零李群上的Laguerre演算"><a href="#2阶幂零李群上的Laguerre演算" class="headerlink" title="2阶幂零李群上的Laguerre演算"></a>2阶幂零李群上的Laguerre演算</h2><h4 id="刻画-R-2n-times-R-r-上2阶幂零李群-N-上的几何结构：从反对称映射到李群到模向量场到-lambda-坐标"><a href="#刻画-R-2n-times-R-r-上2阶幂零李群-N-上的几何结构：从反对称映射到李群到模向量场到-lambda-坐标" class="headerlink" title="刻画$R^{2n}\times R^{r}$上2阶幂零李群$N$上的几何结构：从反对称映射到李群到模向量场到$\lambda$-坐标"></a>刻画$R^{2n}\times R^{r}$上2阶幂零李群$N$上的几何结构：从反对称映射到李群到模向量场到$\lambda$-坐标</h4><ul><li><p>首先由不知道谁给定的反对称映射$B:R^{2n}\times R^{2n}\rightarrow R^r$ （0.4）,</p><ul><li>例如，在H^1上 $B(x,y)&#x3D;(x_1,x_2)\begin{pmatrix} 0 &amp; -1\1 &amp; 0 \end{pmatrix}\begin{pmatrix} y_1\y_2 \end{pmatrix}$ ，当然实在合适的坐标系下。</li></ul></li><li><p>建立 <strong>$R^{2n}\times R^r$ 上的2阶幂零李群结构</strong>:主要是群运算 $(x,u)\cdot (y,s)&#x3D;(x+y,u+s+2B(x,y))$ (0.5);</p><ul><li>$H^1$上: $(x,u)\cdot (y,s)&#x3D;(x+y,u+s+2B(x,y))&#x3D;(x+y,u+s+2(x_1y_2-x_2y_1))$ ,当然还是再合适的坐标系下。</li></ul></li><li><p>接下来在该李群上画出唯一的的<strong>模向量场</strong> $Y_j&#x3D;\partial_{y_j}+2B_{kj}^\beta y_k\partial_{s_\beta}$ ，可证它们是（<strong>最简单的</strong>）左不变向量场，</p><ul><li>其实我们<strong>心里清楚</strong>，它们就是Horizontal distribution。</li><li>$H^1$上: $Y_1&#x3D;\partial_{y_1}-2y_2\partial_s$ , $Y_2&#x3D;\partial_{y_2}+2y_1\partial_s$ ，当然还是在合适的坐标系下。</li></ul></li><li><p>下面把反对称映射$B$进行“浓缩”——定义$B^\lambda(y,y^\prime)&#x3D;\sum \lambda_j B_j(y,y^\prime)$， 这个<strong>新的映射</strong>不再是映到$R^r$上了，而是到 $R$上。且每个映射都加上不知道谁给定的 $\lambda$ 的权重。</p><ul><li>$H^1$上: 由于$r&#x3D;1$, 所以很简单 $B^\lambda&#x3D;\lambda B$ 。</li></ul></li><li><p>下面由开局送的坐标系构建一个使得$B$形式<strong>最简洁</strong>的，所谓 __$\lambda$ -坐标系__。</p><ul><li><p>上面$H^1$例子中说的“合适”坐标系已经就是了，相当于开局就已经给了最好的。</p></li><li><p>可以根据<strong>任意</strong> 方向导数（$R^{2n}$子空间中随便的一个向量场） $\partial_v&#x3D;\sum v_j\partial_{y_j}$ ，去定义一个模向量场的线性组合——当然也是一个Horizontal向量场—— $Y_v:&#x3D;\sum v_j Y_j&#x3D;\partial_v+2B(y,v)\cdot\partial_s$ ,</p><ul><li>也就是说，$\partial_v$为该Horizontal向量场在$R^{2n}$上投影； </li><li>$[Y_v,Y_{v^\prime}]&#x3D;4B(v,v^\prime)\cdot\partial_s$ ，满足2阶bracket generating条件。<ul><li>这与我们对$Y_j$就是horizontal向量场的判断吻合。</li></ul></li><li>$H^1$上: $Y_v&#x3D;\partial_v+2(y_1v_2-y_2v_1)\partial_s$ , 当然还是在合适坐标系下。</li><li><strong>本条意义</strong>：由于一开始不知道谁给定的映射$B$不一定和我们的$R^{2n}$的自然坐标轴契合，也就是说，表述成坐标-矩阵形式可能会看起来很复杂，所以这一条给了我们<strong>扭转乾坤</strong>——换坐标轴的可行性。</li></ul></li><li><p>在一组标准正交基 ${v_1^\lambda,\ldots,v_{2n}^\lambda}$ 下， $B^\lambda(v_{2j-1}^\lambda,v_{2j}^\lambda)&#x3D;\mu_j(\lambda)$ ，其他下标的情况都是0。于是 $B^\lambda$ 可以写为<strong>标准型</strong>样子(0.10)。</p><ul><li>$H^1$上， $v_j^\lambda&#x3D;$ 之前合适坐标系中的基向量，即 $\partial_{y_j}$ , $B^\lambda&#x3D;\begin{pmatrix} 0&amp;-\lambda\ \lambda&amp;0 \end{pmatrix}$ , $\mu(\lambda)&#x3D;\lambda$</li></ul></li><li><p>终于可以把 $y\in R^{2n}$ 写为该基下的坐标了，记为 $y_1^\lambda,\ldots,y_{2n}^\lambda$ ,称为 $\lambda$ -坐标。</p></li><li><p>$H^1$中自然就是之前一直使用的$y_i$了。</p></li></ul></li></ul><p>有了$N$的几何刻画，下面介绍一个$N$上非常重要的左不变微分算子——<strong>Kohn拉普拉斯</strong>： $D_\alpha&#x3D;\Delta_b+i\alpha\cdot\partial_s$ ;其中<strong>次拉普拉斯</strong> $\Delta_b:&#x3D;-\frac{1}{4}\sum Y_kY_k$，$Y_k:&#x3D;\partial_{y_k}+2B_{jk}^\beta y_j\partial_{t_\beta}$ （这不就是之前的模向量场吗？）</p><p>!!! Warning 终极目标<br>    - 我们希望找到该李群上热算子 $\partial_t-D_\alpha$ 的<strong>热核</strong> $h_t(y,s)$ (类比欧氏空间中的热核 $h_t(y)&#x3D;\frac{1}{\sqrt{4\pi t}}e^{-\frac{y^2}{4t}}$ );<br>        - 合理猜测 $h_t(y,s):&#x3D;e^{-tD_\alpha}\delta_0&#x3D;\frac{c}{t^{\nu&#x2F;2}}e^{-g(y,s)}$ ,<br>            - 其中g被称为调整的复值作用量函数，它的角色等同于 $\frac{d_{cc}^2(y,s)}{2t}$ , 且满足Hamilton-Jacobi方程： $\frac{\partial g}{\partial s}+H(y,Y_1g,\ldots,Y_{2n}g)&#x3D;0$ 。<br>            - 尽管目前我们并不知道这个系统的哈氏量H是什么，但惯设为$R^{2n}$子空间上的动能，由<strong>正则变换</strong>，也就是 $\sum 1&#x2F;2(Y_jg)^2$ 。而之所以前面是 $\partial g&#x2F;\partial s$ 而不是对时间求导，是因为s是时间-like的变量，可以用来替换时间。</p><hr><p>下面小节是为了解决这个终极问题，而建立的一个演算系统，也就是本文的标题——$N$上的Laguerre演算。</p><h4 id="仿制Mikhlin的魔法，即把平卷积算子的卷积乘变成“象征”的真·乘法"><a href="#仿制Mikhlin的魔法，即把平卷积算子的卷积乘变成“象征”的真·乘法" class="headerlink" title="仿制Mikhlin的魔法，即把平卷积算子的卷积乘变成“象征”的真·乘法"></a>仿制Mikhlin的魔法，即把平卷积算子的卷积乘变成“象征”的真·乘法</h4><p>Mikhlin对 $R^2$ 上卷积算子的研究。当核为-2阶齐次且满足0均值的时候，可以写成 $f(\theta)&#x2F;r^2&#x3D;\sum f_ke^{ik\theta}&#x2F;r^2$ 样子。反之这样的函数$f(\theta)$也可以诱导一个 $f(\theta)&#x2F;r^2$ 为核的卷积算子。</p><ul><li>这样的核卷积<strong>保持形式</strong>（是作为基的好苗子）；</li><li>可据此定义算子（实际上是对核函数定义）的”象征”$\sigma(\mathbf{F}) &#x3D; \sum_{k \in \mathbb{Z}, k \neq 0} \left( \frac{|k| i^{- |k|}}{2\pi} \right)^{-1} f_k e^{ik\theta}.$<ul><li>前一篇文章已检验过，是0阶齐次，且满足“象征&#x3D;核的傅里叶变换”</li></ul></li><li>这”象征”满足“算子卷积的象征&#x3D;算子象征的乘积”<ul><li>即 $ \sigma(\mathbf{F} * \mathbf{G}) &#x3D; \sigma(\mathbf{F}) \cdot \sigma(\mathbf{G})$</li></ul></li></ul><p>一言以蔽之，Mikhlin演算建立了$R^2$上卷积算子（-2阶齐次核函数）的卷积代数到“象征”函数（0阶齐次）的乘法代数的转换。</p><p>!!! Warning<br>    模仿Mikhlin, 建立2阶幂零李群$N$上的魔法：</p><pre><code>| $R^2$ | $N$ | | :---: | :----: | | PV卷积算子的代数（卷积乘） | 左不变PV卷积算子的卷积代数（不知道为什么，他们都忽略算子而直指核函数） | | （-2阶齐次的）核可以$\&#123;e^&#123;ik\theta&#125;/r^2\&#125;$为基 | 核的部分傅里叶变换可以$\&#123;\tilde&#123;W&#125;_k^&#123;(p)&#125;(\cdot,\lambda)\&#125;$为基|  $\frac&#123;\|k\|i^&#123;- \|k\|&#125;&#125;&#123;2\pi&#125;e^&#123;ik\theta&#125;/r^2$ 卷积保持形式 | $\&#123;\tilde&#123;W&#125;_k^&#123;(p)&#125;(\cdot,\lambda)\&#125;$的twisted卷积也保持形式| Mikhlin象征: 即核的傅里叶变换$\sum \left( \frac&#123;\|k\| i^&#123;- \|k\|&#125;&#125;&#123;2\pi&#125; \right)^&#123;-1&#125; f_k e^&#123;ik\theta&#125;$ | 象征矩阵或张量,$M_\lambda(F):=(F_k^p(\lambda))_&#123;p,k&#125;$：它是核的部分傅里叶变换  $\sum_&#123;p,k&#125;F_k^p(\lambda)\tilde&#123;W&#125;_&#123;p\wedge k-1&#125;^&#123;(p-k)&#125;(y,\lambda)$（的系数） || 交换象征乘法 | 非交换象征矩阵或张量乘法 || $ \sigma(\mathbf&#123;F&#125; * \mathbf&#123;G&#125;) = \sigma(\mathbf&#123;F&#125;) \cdot \sigma(\mathbf&#123;G&#125;)$ | $M_\lambda(\mathbf&#123;F&#125;*\mathbf&#123;G&#125;)=M_\lambda(\mathbf&#123;F&#125;)\cdot M_\lambda(\mathbf&#123;G&#125;)$ |这一套叫做Laguerre演算——它的最初版本是$H_n$上Laguerre函数诱导的象征张量演算。</code></pre><blockquote><p>要想达到这个”仿制”的目的，我们需要比在$R^2$上多一步<strong>过渡</strong>操作——即将$N$上函数的卷积乘转化为$R^{2n}$上的某种运算：</p><ul><li>俩$N$上函数的<strong>卷积</strong>(0.16)，这个是左不变的，也是右不变的;</li><li>$N$上函数的<strong>部分傅里叶变换</strong>，即只针对s做变换，变为其对偶变量 $\lambda$ , 而保留y变量，视$\lambda$为参量，则成为$R^{2n}$上的函数；</li><li>$R^{2n}$ 上俩函数<strong>twisted卷积</strong> $*_\lambda$ ，$ f *<em>\lambda g(y) &#x3D; \int</em>{\mathbb{R}^{2n}} e^{-i2B^\lambda(y, x)} f(y - x) g(x) dx $. 即不单做卷积，还要进行相位的调制；</li><li><strong>联系</strong>：两$N$上函数卷积的部分傅里叶变换**&#x3D;**它们部分傅里叶变换的twisted卷积,<ul><li>即 $ (\widetilde{\varphi * \psi})_\lambda(y) &#x3D; \tilde{\varphi}_\lambda *_\lambda \tilde{\psi}_\lambda $</li><li>笼统地说就是，函数卷积的“傅里叶”&#x3D;函数“傅里叶”的“卷积”；</li><li>$N$上函数的（左不变）卷积代数&lt;&#x3D;&gt;$R^{2n}$上函数的twisted卷积代数。</li></ul></li></ul></blockquote><p>借助这个由$N$到$R^{2n}$的<strong>过渡</strong>，终于可以仿制$N$上的<strong>变象征魔法</strong>。</p><ul><li><p>定义Laguerre函数 $l_k^{(p)}(\lambda)$ ,k取正整数时，可组成$L^2([0,+\infty),d\lambda)$ 的一个标准正交基，对于给定的p。</p></li><li><p>定义 $R^{2n}\times R^{r}$ 上指数Laguerre函数 $W_k^{(p)}$ </p><ul><li>通过其部分傅里叶变换 $\tilde{W}_k^{(p)}(z,\lambda)&#x3D;\cdots l_k^{(p)}(2|\lambda||z|^2)e^{ip\theta}$定义的(0.19)(0.20), </li><li>注意这里就引入了复数 $z_j^\lambda&#x3D;y_{2j-1}^\lambda+iy_{2j}^\lambda$ , 也就是说，将$R^{2n}$赋予复结构，然后在上面定义复算子，会有<strong>天然的适配性</strong>，这里可以参考之前Mikhlin对$R^2$平面上卷积算子的复化处理。</li></ul></li><li><p>现在可以说 ${\tilde{W}<em>k^{(p)}(\cdot,\lambda)}</em>{p\in Z^n,k\in Z_+^n}$ 构成$L^2(R^{2n})$ 上的一组<strong>标准正交基</strong>，且满足类似Mikhlin第一条的性质：两个这样的函数的twisted卷积<strong>保持形式</strong>。</p></li><li><p>有了这样的一组基，便可以将任意 $\tilde{F}<em>\lambda(y)\in L^2(R^{2n})$ 进行<strong>分解</strong> $\tilde{F}<em>\lambda(y)&#x3D;\sum</em>{p,k}F_k^p(\lambda)\tilde{W}</em>{p\wedge k-1}^{(p-k)}(y,\lambda)$ 。</p></li><li><p>把这个分解的<strong>系数提取为矩阵</strong>形式 $M_\lambda(F):&#x3D;(F_k^p(\lambda))_{p,k}$ , 这就是我们寻找的<strong>象征矩阵</strong>或象征张量。</p><ul><li>对于这个张量，有 $M_\lambda(\mathbf{F}*\mathbf{G})&#x3D;M_\lambda(\mathbf{F})\cdot M_\lambda(\mathbf{G})$ , 即类比Mikhlin第三条性质“算子（核函数）卷积的‘象征’&#x3D;算子（核）‘象征’的乘积”。</li><li>于是$R^{2n}$上函数的twisted卷积代数&lt;&#x3D;&gt;（象征）矩阵的乘法代数。</li></ul></li></ul><p>至此我们<strong>已经完成</strong>Laguerre演算的构建。可以理解为以$R^{2n}$上函数的twisted卷积代数为中间等价过渡, 建立$N(H_n)$上左不变PV卷积算子的代数（实际上是核函数的卷积代数）到象征矩阵乘法代数的转换。</p><p>!!! Note 基$\tilde{W}<em>k^{(p)}(z,\lambda)$的具体定义<br>    $\tilde{W}<em>k^{(p)}(z,\lambda):&#x3D;\prod_j\mu_j(\dot{\lambda})\tilde{W}</em>{k_j}^{(p_j)}(\sqrt{\mu_j(\dot{\lambda})}z_j^\lambda,\lambda) :&#x3D;\prod_j\mu_j(\dot{\lambda})\frac{2|\lambda|}{\pi}(\mathrm{sgn} p_j)^{p_j}l</em>{k_j}^{(p_j)}(2|\lambda||\sqrt{\mu_j(\dot{\lambda})}z_j^\lambda|^2)e^{ip_j\theta_j} &#x3D;\prod_j\mu_j(\lambda)\frac{2}{\pi}(\mathrm{sgn} p_j)^{p_j}l_{k_j}^{(p_j)}(2\mu_j(\lambda)|z_j^\lambda|^2)e^{ip_j\theta_j} :&#x3D;\prod_j\mu_j(\lambda)\frac{2}{\pi}(\mathrm{sgn} p_j)^{p_j}[\frac{\Gamma(k_j+1)}{\Gamma(k_j+p_j+1)}]^{1&#x2F;2}L_{k_j}^{(p_j)}(2\mu_j(\lambda)|z_j^\lambda|^2)(2\mu_j(\lambda)|z_j^\lambda|^2)^{p_j&#x2F;2}e^{-\mu_j(\lambda)|z_j^\lambda|^2}e^{ip_j\theta_j}$</p><pre><code>- 在$H_1$这个简单例子里，$j$只能取1， $\mu(\lambda)=\lambda$ , 则上面可简化为 $\tilde&#123;W&#125;_k^&#123;(p)&#125;(z,\lambda)=\lambda [\frac&#123;\Gamma(k+1)&#125;&#123;\Gamma(k+p+1)&#125;]^&#123;1/2&#125;L_k^&#123;(p)&#125;(2\lambda|z^\lambda|^2)(2\lambda|z^\lambda|^2)^&#123;p/2&#125;e^&#123;-\lambda|z^\lambda|^2&#125;e^&#123;ip\theta&#125;$     - 若p取0，则$\tilde&#123;W&#125;_k^&#123;(0)&#125;(z,\lambda)=\lambda L_&#123;k&#125;^&#123;(p)&#125;(2\lambda|z^\lambda|^2)e^&#123;-\lambda|z^\lambda|^2&#125;$ 。</code></pre><p>注意：此处与Greiner’s notes上定义的指数Laguerre函数略有不同，这里使用其部分傅里叶变换定义，那里使用的是全傅里叶变换定义。</p><p>上面定义了函数（核）的部分傅里叶变换，下面定义<strong>算子的</strong>部分傅里叶变换：</p><h6 id="算子级部分傅里叶变换（见之前文章）"><a href="#算子级部分傅里叶变换（见之前文章）" class="headerlink" title="算子级部分傅里叶变换（见之前文章）"></a>算子级部分傅里叶变换（见之前文章）</h6><ul><li>首先，算子的部分傅里叶变换，本质上还是一个算子。只不过保留$R^{2n}$上的算子形式，而将$R^r$上的算子$\partial_s$ 变为傅里叶变换侧的$i\lambda$.<ul><li>如 $ \widetilde{Y_{v_j^\lambda}} &#x3D;\widetilde{\partial_{v_j^\lambda} +2B(y,v_j^\lambda) \cdot \partial_s} &#x3D; \partial_{v_j^\lambda} + 2iB^\lambda(y, v_j^\lambda) &#x3D; \partial_{y_j^\lambda} + 2iB^\lambda(y, v_j^\lambda) $ ，在 $ \lambda $ -坐标系下。<ul><li>回到 $ H_1 $ 的老例子，由于 $ Y_{v_1^\lambda} &#x3D; \partial_{v_1^\lambda} + 2B(y, v_1^\lambda)\partial_s &#x3D; \partial_{v_1^\lambda} - 2y_2\partial_s $ ，所以有 $ \widetilde{Y_{v_1^\lambda}} &#x3D; \partial_{y_1^\lambda} + 2iB^\lambda(y, v_0^\lambda) &#x3D; \partial_{y_1^\lambda} - 2i\lambda y_2^\lambda $ ，同理 $ \widetilde{Y_{v_2^\lambda}} &#x3D; \partial_{y_2^\lambda} + 2i\lambda y_1^\lambda $ ;</li></ul></li><li>又如在复化 $ \lambda $ -坐标系中，由常见的复化horizontal向量场<table><thead><tr><th align="center"></th><th align="center"></th><th align="right"></th></tr></thead><tbody><tr><td align="center">$$Z_j^\lambda :&#x3D; \frac{1}{2}(Y_{v_{2j-1}^\lambda} - iY_{v_{2j}^\lambda})$$</td><td align="center">$$\bar{Z}<em>j^\lambda :&#x3D; \frac{1}{2}(Y</em>{v_{2j-1}^\lambda} + iY_{v_{2j}^\lambda})$$</td><td align="right">$$\partial_{z_j^\lambda} :&#x3D; \frac{1}{2}(\partial_{y_{2j-1}^\lambda} - i\partial_{y_{2j}^\lambda})$$</td></tr></tbody></table>故有 $ \widetilde{Z_j^\lambda} &#x3D; \partial_{z_j^\lambda} - \mu(\lambda)\bar{z}_j^\lambda $ ，同理有 $ \widetilde{\bar{Z}<em>j^\lambda} &#x3D; \partial</em>{\bar{z}_j^\lambda} + \mu(\lambda)z_j^\lambda $ <ul><li>回到$H_1$中，就是<table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">$$Z^\lambda &#x3D; \frac{1}{2}((\partial_{y_1^\lambda} - 2y_2\partial_s) - i(\partial_{y_2^\lambda} + 2y_1\partial_s)) \&#x3D; \partial_{z^\lambda} - (iy_1 + y_2)\partial_s$$</td><td align="center">$$\bar{Z}^\lambda &#x3D; \partial_{\bar{z}^\lambda} + (iy_1 - y_2)\partial_s \&#x3D; \partial_{\bar{z}^\lambda} + iz^\lambda\partial_s$$</td></tr></tbody></table>由这些可定义Hans Lewy 算子，即 $ \tilde{Z}^\lambda &#x3D; \partial_{z^\lambda} - \lambda \bar{z}^\lambda $, $ \tilde{\bar{Z}}^\lambda &#x3D; \partial_{\bar{z}^\lambda} + \lambda z^\lambda $ 。</li></ul></li></ul></li></ul><p>上面这些例子可<strong>不是白举的</strong>。它们可以重新表示我们之前定义的次拉普拉斯</p><p>$$<br>\Delta_b :&#x3D; -\frac{1}{4}\sum_j^{2n} Y_j Y_J &#x3D; -\frac{1}{4}\sum_j^{2n} Y_j^\lambda Y_J^\lambda &#x3D; -\frac{1}{2}\sum_j^n(Z_j^\lambda\bar{Z}_j^\lambda + \bar{Z}_j^\lambda Z_j^\lambda)<br>$$</p><p>由此有<strong>次拉普拉斯的部分傅里叶变换</strong>：</p><p>$$<br>\tilde{\Delta}_b :&#x3D; -\frac{1}{4}\sum_j^{2n}\tilde{Y}_j^\lambda \tilde{Y}_J^\lambda &#x3D; -\frac{1}{2}\sum_j^n(\tilde{Z}_j^\lambda\tilde{\bar{Z}}_j^\lambda + \tilde{\bar{Z}}_j^\lambda \tilde{Z}_j^\lambda)<br>$$</p><blockquote><ul><li>有一个Lemma是这样说的： $ \tilde{Z}<em>j^\lambda\tilde{W}<em>k^{(p)}(y,\lambda) &#x3D; \text{一个}\mu(\lambda), k, p\text{的系数}\tilde{W}</em>{k+1</em>{p_j\ne 0}}^{p-e_j}(y,\lambda) $ ，其中 $ e_j &#x3D; (0,\ldots,1,\ldots,0) $ 只有第 $j$ 个项是 $1$。可以说 $ Z_j^\lambda $ 的部分傅里叶变换作用在Laguerre基上就是<strong>平移算子</strong>的效果(当然不是简单的平移，还要有一些放大或缩小)。<ul><li>$ H^1 $ 上 $ \tilde{Z}^\lambda\tilde{W}<em>k^{(p)}(y,\lambda) &#x3D; \text{一个}\mu(\lambda), k, p\text{的系数}\tilde{W}</em>{k+1_{p\ne 0}}^{p-1}(y,\lambda) $ </li><li>对应量子力学中的<strong>湮灭算符</strong>（或者生成算符，我匹配不太上，反正分别是对应$Z$和$\bar{Z}$）.</li></ul></li></ul></blockquote><hr><h2 id="次拉普拉斯算子的热核"><a href="#次拉普拉斯算子的热核" class="headerlink" title="次拉普拉斯算子的热核"></a>次拉普拉斯算子的热核</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blog-theme-pic</title>
      <link href="/2024/11/22/blog-theme-pic/"/>
      <url>/2024/11/22/blog-theme-pic/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么在文章中插入图片"><a href="#怎么在文章中插入图片" class="headerlink" title="怎么在文章中插入图片"></a>怎么在文章中插入图片</h2><h3 id="Hexo博客插入图片的方法"><a href="#Hexo博客插入图片的方法" class="headerlink" title="Hexo博客插入图片的方法"></a>Hexo博客插入图片的方法</h3><p>绝对引用：</p><p>少量使用图片的时候使用, 将文件放在 &#x2F;source&#x2F;images 文件夹下, 使用 markdown 语法 可以实现图片显示, 但是这种引用在本地markdown 编辑器中会无法预览,因为相对路径不一致,找不到文件, 不过在首页内容和文章正文中都能正常显示,十分方便.<br>总之，这种方法不好用。</p><p>相对引用：</p><p>设置站点配置_config.yml:将post_asset_folder: false改为post_asset_folder: true</p><p>安装插件:npm install <a href="https://github.com/CodeFalling/hexo-asset-image">https://github.com/CodeFalling/hexo-asset-image</a> – save</p><p>运行hexo new post “aaa”,生成aaa.md博文时就会在&#x2F;source&#x2F;_posts目录下生成aaa的文件夹，将你想在aaa博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。</p><p>添加图片:在想添加的位置写入 <code>![]lll(aaa/图片名字.图片格式)</code></p><p>注意：在这里容易出现问题。若不安装该插件（hexo-asset-image），会出现图片路径重复引用，导致图片无法正常显示。安装了该插件之后，直接采用上述格式：![]紧跟着（图片名字.图片格式），这种方式可以在网页正常显示图片但是在vscode里无法预览。此时如果采用这个格式：![]紧跟着（图片所在md文件的文件夹名&#x2F;图片名字.图片格式）就可以正常预览。<br>举个例子吧</p><p><img src="/2024/11/22/blog-theme-pic/addpicture.png" alt="举例图"><br><img src="/2024/11/22/blog-theme-pic/addpicture.png"></p><p>你看这两行的区别。</p><p>例如 <code>![](aaa/1.png)。</code>在线引用：</p><p>如果要引用的图片已经存在于网络上, 直接引用该图片的地址即可</p><p><img src="/2024/11/22/blog-theme-pic/addpicture.png"></p><p><img src="http://images2018.cnblogs.com/blog/1003156/201806/1003156-20180604175546711-227291592.png" alt="百度图"></p><p>如果不存在于网络上, 可以使用在线图床上传之后得到链接使用,</p><p>比如使用 sm.ms, 聚合图床.</p>]]></content>
      
      
      <categories>
          
          <category> blog主题使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blog-theme</title>
      <link href="/2024/11/22/blog-theme/"/>
      <url>/2024/11/22/blog-theme/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f15b59036de676070ecca088aa8c8bf4fab14b1f9ab5b99001699a0964e5f728">cb0a42d0d1dfc9314ab94d7f2823c942db701a2f9de02ea6d3f35dbbfa42ae0249912013ff0fa3456687046697f905cddb8056fad6f2c8782d32aec359b234b0df74c3560404c71d4ea0e8efae0afb2dd8076f8f39a837b98ecd4341ab8864730dcc4a37bdff7b07b00eada0beb29172f12313bddf5f472d8b7e4a5a1b8e102af9249da107e105b71c4e9b56df28565a5b62bba148e73cbafc36f854e0f359eeee5e1fe263018310d384379d5c7d22e070d438c6eaa1175b0b4eef2e9552c9247fe9fc046f7ef354fb7af20a6bfc189466824bf4ac372ec6285d576f67e2c94ffebae626891d645ffc6b802e8c6e478fb16cb9b29e39bbbfeca2bd4343b22b5cfbc330f611851ef43aa8f78e7abcf43410d7993068f84c3080b10499d5cf8f515cfa65baace7abc65a0f39b91cd30b141d705aa12bc8da1c3926905f614176cffc46b4f0b57b6235444753e7ca12c3345848e53db44b48a86df24d99c2aeff19c77c292d27959be44bfefee9b552abc0ef946a8976c9f2ed8bd97cc8ac3cf4409af280ae05870b0ea91bd992f61f9673f06e0c2f635319250b3549689bfd2438594bd8fb4b94c25c1cee22773f5e58310578ae41cd32d6f0dbbfb741613694f782917835d579f876de8a6c99443c1e06edd9fb84fd4573a342bd0f053729d1d9d1d6448d4851408c5f7157bf34ea270b92107cfeff01927c081a05451a4ae3509739b4a7c5f7d0daa8dc782b4d76a9f483fb87432044754754202fda52924d112af2da0d1d3d41259c24f92eb39ae814fc8b2e64e133ec7f2dd0951ddfae738485b95b69d0cbaa883b98c905b61812978aa33219c51613032fcd71bcb45cc9e86ffaeb411870cc3f8051bcd30258af88b7a0a99b13bfbce6932bd1ff70279657051d89d98346f2c5c86b77fd1b490f9e42928bf8fbff1d873ff35babcf30c610ecc83e95aca04092c92d579e1b07fb9c88366ecdd7f308e3c42e490eecacfaec2d77236e448e93a8bac800a708cad99f8e10d0867ba9076f531511871fb280790cca6c512281919c3c4dce7e9b80aa44ab12f4b5be8cce5287d577ab9d146863c6815d97236bef92878e40d8f5fe4636ed62892d3365c1464b507aea6ef3d389adbabfdf82384b988bfbb641061c2b769574f78f151625c62197809cb71ac99383a4f295152cf0182c79d3183f58b67ccbd48b53dc9e4e007ba4e599132b020f5b8235c3981854f019094aa3076714e3a3c3f5a9d6fd8b65416c9d1b558f49ba35485d717c8b21a9d0accd6c01e16b8e9b4c366b2d674e5fdd7156c420f1c0fa7847c1e43dbd8af9e3d43ed200c33c3b527572993ed311238c1aef253aff4b0f42341da58488c965b4e4aa6b52ba0a7847c265b1e34bf0df98b9b7c92ca554c96c1cbfdc244d0e94b2541f9aed2e778af222eb1d177b1cb81d09b6a76f6db1e4a9912fcc39761e7beacf35bd6d4cd9f9fb4cc06cf6f9ea480498aa4ba7a1510a9dd11e6685862aca20d2ffbdce0381610ed20b0268813eb255c8c500676a1489677cb0b06540591940e0a7c78fad0fc37a17b7fecc5302f93a866f849c7ceddec8063e1417ef597d09553934a7e13dd0fe4713469f437acb9e1343d55a21a730eb1837732595f1c173cadffff7beb8c483a4260097751417ec99b30093236ba9fcba7be724a7f7318f50c2740bae1bfbe5044fbf845134369dbb605d2f139f215173240dc018d45e61fa8f7e3ee077532ec5c4755978ac181c4ef3e0a41c53714f5ed24ad05c77b412f7ded4167bc1ec40b2299a01e31c495f102fe058be3d0a3f4d4a6b30f63d34ef08876dc0e054dffc5865cc312bb9db30940e419e30f353362386a74b0d76123cdf985c86c2e73c0dd62603c78977c0b5acad0084d53f16e57008ee9682ad759cd10950747fb5116524a2ab61fbeb8c18a0ad387967cc84ea369c2944ddc9c38e779a218a7679def387e44cbf83242ad90120baf604eb2923b2c46b784b8e0927ad0b2e6dc70af9f33890e79e7058f5c1041828c3c6c704741227cc16ec5d1561111f12b40ddb297487330135ca554edd756f18fb9e92a40f8813fa6545e005c648185593d682fcdb77e3cc8d1648246a18d91c8721f4c0c4ddb353ec954ebc0a3b28e23029fc05c2ab4dc94dec8febd8d7fdffa9cbde3dcbf9e7bdaaa11d1c8139073774c9bb8202bfd78b54f67a7a5b535f155d59de91db93b6b78a2815d7ddf27fdbc025a4dd84c9ff4f85bcbeace41d845a551af0017bf9eb6429f03415818a09cf53ea08c7ad631b9c2c1ee57c9a722aa0b289d918975fc9a21ac3c8fba078d0f45cab87c2fab9de4bcadf347122e815c0f6ba47cb02adbc7c6212b7ed97748a8bd55e4fd6ef88717b59b4e5da615540df6207907bfc6120bbadc045bb04d27db19d21758be19a5e8281ad3970748197e761ded95e8db0aebcb9857bc24f6fb6ab8511fca473b5fd581b30f02d6e5befc71b53c568bf5e0041cec2540fa3c684174ef7ed9914510cd251aec38dcc06fc58ca0889440b1ebf49156f3a78653806c4573a231ccae07d4a9a0c30b5b023c58973e431ce998eecc119dbb78494bcc91da2ef23d4ae8c0cbdea1afce292afb19f1f5b75f287833612debae2f89e649e4a3721f61e3d76a916a2f0a1e06e0010897dd1efc74d41dfc1d07c3924cdf5ad43e0ebc1dbd514858f60e39c40c7f7b24b914fa6e78f14b531e18d49829b466ce24e257f5c751b6bb5c4353a15202a7b1bf7ab7695bb8bea37f6f78f9fc7f23d170a8d26edeeed521bd1316b68072bbc342adf1a3ff5b2c3479c2135b1e385cfca839338c87235af4b67ec4f35c7601c07c4aabb8fc659244d6f32393652249ed0ad7289769018dcf53895afdd84f1e87035978a0ef70e4dc288d5c17f46475e9412ed4c817879253a5bd697d0bb4c3d1199cc2d58a33b034a72592320ef0fdd6337c3477aec1f99165c3df11fd81ed748dee27f05f2ee530b374a97bb967cf069e3172a65f37e93dc53611c7424e9b905a244285fce073917a38db53ae6205ec6d3e444e987a38a7f088401d58c109fe07503daf83c02d5cdfb5edcb4c39c5a5e1095aba2fd24b7163e68f853a69466e8730ed23a2e94a6200d347dc48f5b9533c9448b1704c84fe381646600308e1b490d71e88a2a8636c163d95eba0ecfaa51ea3f5e03fcf66916dc6fdeb8cf65ec2f255dbf8f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> blog主题使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>脑机实验</title>
      <link href="/2024/09/07/jue-mi/"/>
      <url>/2024/09/07/jue-mi/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="66a7e83acd4c82264c440d78bf3a64a0997cd1e3b755e4c50c98504e0a0a3ab7">cb0a42d0d1dfc9314ab94d7f2823c942db701a2f9de02ea6d3f35dbbfa42ae025e3e8b3f062a2a6478726c0286ec819d1e80d0c48a472806ecf25cad27359054c393d24c738e0fb42904381f8bf869420c91cc4b1bc1012bf2e825b7652289837e8faa8796c5545aaf41e49c86674f70e924d55731ef1a9b4d8cac1cb631dfb193d532fa48102b8aa6ec07843110cdf8ca7f30cd5f424f3d2f38f62cbfeba291f062f0397078afefe00ad6187c803373312fd231da01865f04bbba193366df8e1f1fa01dad418c734d436f715010c66b7b8e7497e8186c7cafe440d8dfb5f95d823d708ea24a09d5c445a97b2f34f9963d7b1479de524c25c6efcb6236314e791191e40917debf5219ab1a6939c41824b4b00ed22d6e04f429cd21364171aee0e62bcb973bb369266bd223d0f6131674308c1fcf9238e85ed04e739ac18685aca4fd004a14912ef3fa7320e2499f44f0aab45bb70c473ff812ea62d7952d42005c8b1962204e404d22077ccc6ff7d037afc7351e3e9f86383351a67dc9ab4b6b61204ac972d62ed650a2d8b6f2b676cc300a425ec98496b337456bbcc51cf25084c45e3f72221d6601245e654c3b5c44</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> BCI 头脑风暴 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
